// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436
namespace Windows.Win32
{
    using global::System;
    using global::System.Diagnostics;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;
    using global::System.Runtime.Versioning;
    using win32 = global::Windows.Win32;

    public static partial class Kernel32
    {
        /// <summary>Closes an open object handle.</summary>
        /// <param name="hObject">A valid handle to an open object.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-closehandle">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows5.0")]
        public static extern win32.Foundation.BOOL CloseHandle(win32.Foundation.HANDLE hObject);

        /// <inheritdoc cref="VirtualQueryEx(win32.Foundation.HANDLE, void*, win32.System.Memory.MEMORY_BASIC_INFORMATION*, nuint)"/>
        [SupportedOSPlatform("windows5.1.2600")]
        public static unsafe nuint VirtualQueryEx(SafeHandle hProcess, void* lpAddress, out win32.System.Memory.MEMORY_BASIC_INFORMATION lpBuffer, nuint dwLength)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (win32.System.Memory.MEMORY_BASIC_INFORMATION* lpBufferLocal = &lpBuffer)
                {
                    win32.Foundation.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.Foundation.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.Foundation.HANDLE);
                    nuint __result = Kernel32.VirtualQueryEx(hProcessLocal, lpAddress, lpBufferLocal, dwLength);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Retrieves information about a range of pages within the virtual address space of a specified process.</summary>
        /// <param name="hProcess">
        /// <para>A handle to the process whose memory information is queried. The handle must have been opened with the <b>PROCESS_QUERY_INFORMATION</b> access right, which enables using the handle to read information from the process object. For more information, see <a href="https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualqueryex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name="lpAddress">
        /// <para>A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page boundary. To determine the size of a page on the host computer, use the <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function. If <i>lpAddress</i> specifies an address above the highest memory address accessible to the process, the function fails with <b>ERROR_INVALID_PARAMETER</b>.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualqueryex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name="lpBuffer">
        /// <para>A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-memory_basic_information">MEMORY_BASIC_INFORMATION</a> structure in which information about the specified page range is returned.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualqueryex#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name="dwLength">The size of the buffer pointed to by the <i>lpBuffer</i> parameter, in bytes.</param>
        /// <returns>
        /// <para>The return value is the actual number of bytes returned in the information buffer. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error values include <b>ERROR_INVALID_PARAMETER</b>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualqueryex">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows5.1.2600")]
        public static extern unsafe nuint VirtualQueryEx(win32.Foundation.HANDLE hProcess, [Optional] void* lpAddress, win32.System.Memory.MEMORY_BASIC_INFORMATION* lpBuffer, nuint dwLength);

        /// <inheritdoc cref="IsWow64Process(win32.Foundation.HANDLE, win32.Foundation.BOOL*)"/>
        [SupportedOSPlatform("windows6.0.6000")]
        public static unsafe win32.Foundation.BOOL IsWow64Process(SafeHandle hProcess, out win32.Foundation.BOOL Wow64Process)
        {
            bool hProcessAddRef = false;
            try
            {
                fixed (win32.Foundation.BOOL* Wow64ProcessLocal = &Wow64Process)
                {
                    win32.Foundation.HANDLE hProcessLocal;
                    if (hProcess is object)
                    {
                        hProcess.DangerousAddRef(ref hProcessAddRef);
                        hProcessLocal = (win32.Foundation.HANDLE)hProcess.DangerousGetHandle();
                    }
                    else
                        hProcessLocal = default(win32.Foundation.HANDLE);
                    win32.Foundation.BOOL __result = Kernel32.IsWow64Process(hProcessLocal, Wow64ProcessLocal);
                    return __result;
                }
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Determines whether the specified process is running under WOW64 or an Intel64 of x64 processor.</summary>
        /// <param name="hProcess">
        /// <para>A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>. <b>Windows Server 2003 and Windows XP:  </b>The handle must have the PROCESS_QUERY_INFORMATION access right.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-iswow64process#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name="Wow64Process">A pointer to a value that is set to TRUE if the process is running under WOW64 on an Intel64 or x64 processor. If the process is running under 32-bit Windows, the value is set to FALSE. If the process is a 32-bit application running under 64-bit Windows 10 on ARM, the value is set to FALSE. If the process is a 64-bit application running under 64-bit Windows, the value is also set to FALSE.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-iswow64process">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows6.0.6000")]
        public static extern unsafe win32.Foundation.BOOL IsWow64Process(win32.Foundation.HANDLE hProcess, win32.Foundation.BOOL* Wow64Process);

        /// <inheritdoc cref="ReadProcessMemory(win32.Foundation.HANDLE, void*, void*, nuint, nuint*)"/>
        [SupportedOSPlatform("windows5.1.2600")]
        public static unsafe win32.Foundation.BOOL ReadProcessMemory(SafeHandle hProcess, void* lpBaseAddress, void* lpBuffer, nuint nSize, nuint* lpNumberOfBytesRead)
        {
            bool hProcessAddRef = false;
            try
            {
                win32.Foundation.HANDLE hProcessLocal;
                if (hProcess is object)
                {
                    hProcess.DangerousAddRef(ref hProcessAddRef);
                    hProcessLocal = (win32.Foundation.HANDLE)hProcess.DangerousGetHandle();
                }
                else
                    hProcessLocal = default(win32.Foundation.HANDLE);
                win32.Foundation.BOOL __result = Kernel32.ReadProcessMemory(hProcessLocal, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
                return __result;
            }
            finally
            {
                if (hProcessAddRef)
                    hProcess.DangerousRelease();
            }
        }

        /// <summary>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.</summary>
        /// <param name="hProcess">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
        /// <param name="lpBaseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
        /// <param name="lpBuffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
        /// <param name="nSize">The number of bytes to be read from the specified process.</param>
        /// <param name="lpNumberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer. If *lpNumberOfBytesRead* is **NULL**, the parameter is ignored.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get extended error information, call [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md). The function fails if the requested read operation crosses into an area of the process that is inaccessible.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-readprocessmemory">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows5.1.2600")]
        public static extern unsafe win32.Foundation.BOOL ReadProcessMemory(win32.Foundation.HANDLE hProcess, void* lpBaseAddress, void* lpBuffer, nuint nSize, [Optional] nuint* lpNumberOfBytesRead);

        /// <inheritdoc cref="OpenProcess(win32.System.Threading.PROCESS_ACCESS_RIGHTS, win32.Foundation.BOOL, uint)"/>
        [SupportedOSPlatform("windows5.1.2600")]
        public static unsafe Microsoft.Win32.SafeHandles.SafeFileHandle OpenProcess_SafeHandle(win32.System.Threading.PROCESS_ACCESS_RIGHTS dwDesiredAccess, win32.Foundation.BOOL bInheritHandle, uint dwProcessId)
        {
            win32.Foundation.HANDLE __result = Kernel32.OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);
            return new Microsoft.Win32.SafeHandles.SafeFileHandle(__result, ownsHandle: true);
        }

        /// <summary>Opens an existing local process object.</summary>
        /// <param name="dwDesiredAccess">
        /// <para>The access to the process object. This access right is checked against the  security descriptor for the process. This parameter can be one or more of the <a href="https://docs.microsoft.com/windows/desktop/ProcThread/process-security-and-access-rights">process access rights</a>. If the caller has enabled the SeDebugPrivilege privilege, the requested access is  granted regardless of the contents of the security descriptor.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-openprocess#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name="bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name="dwProcessId">
        /// <para>The identifier of the local process to be opened. If the specified process is the System Idle Process (0x00000000), the function fails and the last error code is `ERROR_INVALID_PARAMETER`. If the specified process is the System process or one of the Client Server Run-Time Subsystem (CSRSS) processes, this function fails and the last error code is `ERROR_ACCESS_DENIED` because their access restrictions prevent user-level code from opening them. If you are using <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocessid">GetCurrentProcessId</a> as an argument to this function, consider using <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess">GetCurrentProcess</a> instead of OpenProcess, for improved performance.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-openprocess#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is NULL. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-openprocess">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows5.1.2600")]
        public static extern win32.Foundation.HANDLE OpenProcess(win32.System.Threading.PROCESS_ACCESS_RIGHTS dwDesiredAccess, win32.Foundation.BOOL bInheritHandle, uint dwProcessId);

        /// <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
        /// <param name="hLibModule">
        /// <para>A handle to the loaded library module. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freelibrary">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows5.1.2600")]
        public static extern win32.Foundation.BOOL FreeLibrary(win32.Foundation.HINSTANCE hLibModule);

        /// <inheritdoc cref="LoadLibrary(win32.Foundation.PCWSTR)"/>
        [SupportedOSPlatform("windows5.1.2600")]
        public static unsafe Kernel32.FreeLibrarySafeHandle LoadLibrary(string lpLibFileName)
        {
            fixed (char* lpLibFileNameLocal = lpLibFileName)
            {
                win32.Foundation.HINSTANCE __result = Kernel32.LoadLibrary(lpLibFileNameLocal);
                return new Kernel32.FreeLibrarySafeHandle(__result, ownsHandle: true);
            }
        }


        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref="Kernel32.FreeLibrary"/>.
        /// </summary>
        public class FreeLibrarySafeHandle
            : SafeHandle
        {
            private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            public FreeLibrarySafeHandle() : base(INVALID_HANDLE_VALUE, true)
            {
            }
            public FreeLibrarySafeHandle(IntPtr preexistingHandle, bool ownsHandle = true) : base(INVALID_HANDLE_VALUE, ownsHandle)
            {
                this.SetHandle(preexistingHandle);
            }

            public override bool IsInvalid => this.handle == default(IntPtr) || this.handle == INVALID_HANDLE_VALUE;

            protected override bool ReleaseHandle() => Kernel32.FreeLibrary((win32.Foundation.HINSTANCE)this.handle);
        }

        /// <summary>Loads the specified module into the address space of the calling process.</summary>
        /// <param name="lpLibFileName">
        /// <para>The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file). The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file. If the string specifies a full path, the function searches only that path for the module. If the string specifies a relative path or a module name without a path, the function uses a standard search strategy to find the module; for more information, see the Remarks. If the function cannot find the  module, the function fails. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>. If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadlibraryw#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the module. If the function fails, the return value is NULL. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadlibraryw">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("Kernel32", ExactSpelling = true, EntryPoint = "LoadLibraryW", SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows5.1.2600")]
        public static extern win32.Foundation.HINSTANCE LoadLibrary(win32.Foundation.PCWSTR lpLibFileName);
    }
}
